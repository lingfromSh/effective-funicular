{"_id":"note:h7OcRhXS6","title":"智能彩色化图像","content":"# 智能彩色化图像\n\n## 代码\n\nbase_color.py\n```python\nimport torch\nfrom torch import nn\n\nclass BaseColor(nn.Module):\n\tdef __init__(self):\n\t\tsuper(BaseColor, self).__init__()\n\n\t\tself.l_cent = 50.\n\t\tself.l_norm = 100.\n\t\tself.ab_norm = 110.\n\n\tdef normalize_l(self, in_l):\n\t\treturn (in_l-self.l_cent)/self.l_norm\n\n\tdef unnormalize_l(self, in_l):\n\t\treturn in_l*self.l_norm + self.l_cent\n\n\tdef normalize_ab(self, in_ab):\n\t\treturn in_ab/self.ab_norm\n\n\tdef unnormalize_ab(self, in_ab):\n\t\treturn in_ab*self.ab_norm\n\n```\n\nsiggraph17.py\n```python\nimport torch\nimport torch.nn as nn\n\nfrom .base_color import *\n\nclass SIGGRAPHGenerator(BaseColor):\n    def __init__(self, norm_layer=nn.BatchNorm2d, classes=529):\n        super(SIGGRAPHGenerator, self).__init__()\n\n        # Conv1\n        model1=[nn.Conv2d(4, 64, kernel_size=3, stride=1, padding=1, bias=True),]\n        model1+=[nn.ReLU(True),]\n        model1+=[nn.Conv2d(64, 64, kernel_size=3, stride=1, padding=1, bias=True),]\n        model1+=[nn.ReLU(True),]\n        model1+=[norm_layer(64),]\n        # add a subsampling operation\n\n        # Conv2\n        model2=[nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1, bias=True),]\n        model2+=[nn.ReLU(True),]\n        model2+=[nn.Conv2d(128, 128, kernel_size=3, stride=1, padding=1, bias=True),]\n        model2+=[nn.ReLU(True),]\n        model2+=[norm_layer(128),]\n        # add a subsampling layer operation\n\n        # Conv3\n        model3=[nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1, bias=True),]\n        model3+=[nn.ReLU(True),]\n        model3+=[nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1, bias=True),]\n        model3+=[nn.ReLU(True),]\n        model3+=[nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1, bias=True),]\n        model3+=[nn.ReLU(True),]\n        model3+=[norm_layer(256),]\n        # add a subsampling layer operation\n\n        # Conv4\n        model4=[nn.Conv2d(256, 512, kernel_size=3, stride=1, padding=1, bias=True),]\n        model4+=[nn.ReLU(True),]\n        model4+=[nn.Conv2d(512, 512, kernel_size=3, stride=1, padding=1, bias=True),]\n        model4+=[nn.ReLU(True),]\n        model4+=[nn.Conv2d(512, 512, kernel_size=3, stride=1, padding=1, bias=True),]\n        model4+=[nn.ReLU(True),]\n        model4+=[norm_layer(512),]\n\n        # Conv5\n        model5=[nn.Conv2d(512, 512, kernel_size=3, dilation=2, stride=1, padding=2, bias=True),]\n        model5+=[nn.ReLU(True),]\n        model5+=[nn.Conv2d(512, 512, kernel_size=3, dilation=2, stride=1, padding=2, bias=True),]\n        model5+=[nn.ReLU(True),]\n        model5+=[nn.Conv2d(512, 512, kernel_size=3, dilation=2, stride=1, padding=2, bias=True),]\n        model5+=[nn.ReLU(True),]\n        model5+=[norm_layer(512),]\n\n        # Conv6\n        model6=[nn.Conv2d(512, 512, kernel_size=3, dilation=2, stride=1, padding=2, bias=True),]\n        model6+=[nn.ReLU(True),]\n        model6+=[nn.Conv2d(512, 512, kernel_size=3, dilation=2, stride=1, padding=2, bias=True),]\n        model6+=[nn.ReLU(True),]\n        model6+=[nn.Conv2d(512, 512, kernel_size=3, dilation=2, stride=1, padding=2, bias=True),]\n        model6+=[nn.ReLU(True),]\n        model6+=[norm_layer(512),]\n\n        # Conv7\n        model7=[nn.Conv2d(512, 512, kernel_size=3, stride=1, padding=1, bias=True),]\n        model7+=[nn.ReLU(True),]\n        model7+=[nn.Conv2d(512, 512, kernel_size=3, stride=1, padding=1, bias=True),]\n        model7+=[nn.ReLU(True),]\n        model7+=[nn.Conv2d(512, 512, kernel_size=3, stride=1, padding=1, bias=True),]\n        model7+=[nn.ReLU(True),]\n        model7+=[norm_layer(512),]\n\n        # Conv7\n        model8up=[nn.ConvTranspose2d(512, 256, kernel_size=4, stride=2, padding=1, bias=True)]\n        model3short8=[nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1, bias=True),]\n\n        model8=[nn.ReLU(True),]\n        model8+=[nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1, bias=True),]\n        model8+=[nn.ReLU(True),]\n        model8+=[nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1, bias=True),]\n        model8+=[nn.ReLU(True),]\n        model8+=[norm_layer(256),]\n\n        # Conv9\n        model9up=[nn.ConvTranspose2d(256, 128, kernel_size=4, stride=2, padding=1, bias=True),]\n        model2short9=[nn.Conv2d(128, 128, kernel_size=3, stride=1, padding=1, bias=True),]\n        # add the two feature maps above        \n\n        model9=[nn.ReLU(True),]\n        model9+=[nn.Conv2d(128, 128, kernel_size=3, stride=1, padding=1, bias=True),]\n        model9+=[nn.ReLU(True),]\n        model9+=[norm_layer(128),]\n\n        # Conv10\n        model10up=[nn.ConvTranspose2d(128, 128, kernel_size=4, stride=2, padding=1, bias=True),]\n        model1short10=[nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1, bias=True),]\n        # add the two feature maps above\n\n        model10=[nn.ReLU(True),]\n        model10+=[nn.Conv2d(128, 128, kernel_size=3, dilation=1, stride=1, padding=1, bias=True),]\n        model10+=[nn.LeakyReLU(negative_slope=.2),]\n\n        # classification output\n        model_class=[nn.Conv2d(256, classes, kernel_size=1, padding=0, dilation=1, stride=1, bias=True),]\n\n        # regression output\n        model_out=[nn.Conv2d(128, 2, kernel_size=1, padding=0, dilation=1, stride=1, bias=True),]\n        model_out+=[nn.Tanh()]\n\n        self.model1 = nn.Sequential(*model1)\n        self.model2 = nn.Sequential(*model2)\n        self.model3 = nn.Sequential(*model3)\n        self.model4 = nn.Sequential(*model4)\n        self.model5 = nn.Sequential(*model5)\n        self.model6 = nn.Sequential(*model6)\n        self.model7 = nn.Sequential(*model7)\n        self.model8up = nn.Sequential(*model8up)\n        self.model8 = nn.Sequential(*model8)\n        self.model9up = nn.Sequential(*model9up)\n        self.model9 = nn.Sequential(*model9)\n        self.model10up = nn.Sequential(*model10up)\n        self.model10 = nn.Sequential(*model10)\n        self.model3short8 = nn.Sequential(*model3short8)\n        self.model2short9 = nn.Sequential(*model2short9)\n        self.model1short10 = nn.Sequential(*model1short10)\n\n        self.model_class = nn.Sequential(*model_class)\n        self.model_out = nn.Sequential(*model_out)\n\n        self.upsample4 = nn.Sequential(*[nn.Upsample(scale_factor=4, mode='bilinear'),])\n        self.softmax = nn.Sequential(*[nn.Softmax(dim=1),])\n\n    def forward(self, input_A, input_B=None, mask_B=None):\n        if(input_B is None):\n            input_B = torch.cat((input_A*0, input_A*0), dim=1)\n        if(mask_B is None):\n            mask_B = input_A*0\n\n        conv1_2 = self.model1(torch.cat((self.normalize_l(input_A),self.normalize_ab(input_B),mask_B),dim=1))\n        conv2_2 = self.model2(conv1_2[:,:,::2,::2])\n        conv3_3 = self.model3(conv2_2[:,:,::2,::2])\n        conv4_3 = self.model4(conv3_3[:,:,::2,::2])\n        conv5_3 = self.model5(conv4_3)\n        conv6_3 = self.model6(conv5_3)\n        conv7_3 = self.model7(conv6_3)\n\n        conv8_up = self.model8up(conv7_3) + self.model3short8(conv3_3)\n        conv8_3 = self.model8(conv8_up)\n        conv9_up = self.model9up(conv8_3) + self.model2short9(conv2_2)\n        conv9_3 = self.model9(conv9_up)\n        conv10_up = self.model10up(conv9_3) + self.model1short10(conv1_2)\n        conv10_2 = self.model10(conv10_up)\n        out_reg = self.model_out(conv10_2)\n\n        conv9_up = self.model9up(conv8_3) + self.model2short9(conv2_2)\n        conv9_3 = self.model9(conv9_up)\n        conv10_up = self.model10up(conv9_3) + self.model1short10(conv1_2)\n        conv10_2 = self.model10(conv10_up)\n        out_reg = self.model_out(conv10_2)\n\n        return self.unnormalize_ab(out_reg)\n\ndef siggraph17(pretrained=True):\n    model = SIGGRAPHGenerator()\n    if(pretrained):\n        import torch.utils.model_zoo as model_zoo\n        model.load_state_dict(model_zoo.load_url('https://colorizers.s3.us-east-2.amazonaws.com/siggraph17-df00044c.pth',map_location='cpu',check_hash=True))\n    return model\n\n```\n\nutils.py\n```python\n\nfrom PIL import Image\nimport numpy as np\nfrom skimage import color\nimport torch\nimport torch.nn.functional as F\nfrom IPython import embed\n\ndef load_img(img_path):\n\tout_np = np.asarray(Image.open(img_path))\n\tif(out_np.ndim==2):\n\t\tout_np = np.tile(out_np[:,:,None],3)\n\treturn out_np\n\ndef resize_img(img, HW=(256,256), resample=3):\n\treturn np.asarray(Image.fromarray(img).resize((HW[1],HW[0]), resample=resample))\n\ndef preprocess_img(img_rgb_orig, HW=(256,256), resample=3):\n\t# return original size L and resized L as torch Tensors\n\timg_rgb_rs = resize_img(img_rgb_orig, HW=HW, resample=resample)\n\t\n\timg_lab_orig = color.rgb2lab(img_rgb_orig)\n\timg_lab_rs = color.rgb2lab(img_rgb_rs)\n\n\timg_l_orig = img_lab_orig[:,:,0]\n\timg_l_rs = img_lab_rs[:,:,0]\n\n\ttens_orig_l = torch.Tensor(img_l_orig)[None,None,:,:]\n\ttens_rs_l = torch.Tensor(img_l_rs)[None,None,:,:]\n\n\treturn (tens_orig_l, tens_rs_l)\n\ndef postprocess_tens(tens_orig_l, out_ab, mode='bilinear'):\n\t# tens_orig_l \t1 x 1 x H_orig x W_orig\n\t# out_ab \t\t1 x 2 x H x W\n\n\tHW_orig = tens_orig_l.shape[2:]\n\tHW = out_ab.shape[2:]\n\n\t# call resize function if needed\n\tif(HW_orig[0]!=HW[0] or HW_orig[1]!=HW[1]):\n\t\tout_ab_orig = F.interpolate(out_ab, size=HW_orig, mode='bilinear')\n\telse:\n\t\tout_ab_orig = out_ab\n\n\tout_lab_orig = torch.cat((tens_orig_l, out_ab_orig), dim=1)\n\treturn color.lab2rgb(out_lab_orig.data.cpu().numpy()[0,...].transpose((1,2,0)))\n\n```\n\ndemo_release.py\n```python\n\nimport argparse\nimport matplotlib\nmatplotlib.use('TkAgg')\nimport matplotlib.pyplot as plt\nfrom colorizers import *\n\nparser = argparse.ArgumentParser()\nparser.add_argument('-i','--img_path', type=str, default='imgs/ansel_adams3.jpg')\nparser.add_argument('--use_gpu', action='store_true', help='whether to use GPU')\nparser.add_argument('-o','--save_prefix', type=str, default='saved', help='will save into this file with {eccv16.png, siggraph17.png} suffixes')\nopt = parser.parse_args()\n\n# load colorizers\ncolorizer_eccv16 = eccv16(pretrained=False).eval()\ncolorizer_siggraph17 = siggraph17(pretrained=False).eval()\nif(opt.use_gpu):\n\tcolorizer_eccv16.cuda()\n\tcolorizer_siggraph17.cuda()\n\n# default size to process images is 256x256\n# grab L channel in both original (\"orig\") and resized (\"rs\") resolutions\nimg = load_img(opt.img_path)\n(tens_l_orig, tens_l_rs) = preprocess_img(img, HW=(256,256))\nif(opt.use_gpu):\n\ttens_l_rs = tens_l_rs.cuda()\n\n# colorizer outputs 256x256 ab map\n# resize and concatenate to original L channel\nimg_bw = postprocess_tens(tens_l_orig, torch.cat((0*tens_l_orig,0*tens_l_orig),dim=1))\nout_img_eccv16 = postprocess_tens(tens_l_orig, colorizer_eccv16(tens_l_rs).cpu())\nout_img_siggraph17 = postprocess_tens(tens_l_orig, colorizer_siggraph17(tens_l_rs).cpu())\n\nplt.imsave('%s_eccv16.png'%opt.save_prefix, out_img_eccv16)\nplt.imsave('%s_siggraph17.png'%opt.save_prefix, out_img_siggraph17)\n\nplt.figure(figsize=(12,8))\nplt.subplot(2,2,1)\nplt.imshow(img)\nplt.title('Original')\nplt.axis('off')\n\nplt.subplot(2,2,2)\nplt.imshow(img_bw)\nplt.title('Input')\nplt.axis('off')\n\nplt.subplot(2,2,3)\nplt.imshow(out_img_eccv16)\nplt.title('Output (ECCV 16)')\nplt.axis('off')\n\nplt.subplot(2,2,4)\nplt.imshow(out_img_siggraph17)\nplt.title('Output (SIGGRAPH 17)')\nplt.axis('off')\nplt.show()\n```","tags":[],"folderPathname":"/计算机视觉","data":{},"createdAt":"2020-12-07T15:09:21.994Z","updatedAt":"2020-12-07T15:11:49.975Z","trashed":false,"_rev":"HmH_ImYzc"}