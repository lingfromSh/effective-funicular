{"_id":"note:dxMnX6LpV","title":"运动跟踪 Object Tracking","content":"# 运动跟踪 Object Tracking\n\n## 卡尔曼滤波器\n\n> 知乎 (https://zhuanlan.zhihu.com/p/42390886)\n\n1. 选取K-1时刻的最优估计Xk-1为基准\n2. 预测K时刻的状态变量，得到Xk'\n3. 观测K时刻的状态变量，得到Zk\n4. 用Zk修正Xk'\n5. 得到K时刻的最优估计Xk\n6. 重复1-5步骤。\n\n```python\nclass KalmanFilter(object):\n    \"\"\"Implements the Kalman Filter, Kalman Smoother, and EM algorithm.\n    This class implements the Kalman Filter, Kalman Smoother, and EM Algorithm\n    for a Linear Gaussian model specified by,\n    .. math::\n        x_{t+1}   &= A_{t} x_{t} + b_{t} + \\\\text{Normal}(0, Q_{t}) \\\\\\\\\n        z_{t}     &= C_{t} x_{t} + d_{t} + \\\\text{Normal}(0, R_{t})\n    The Kalman Filter is an algorithm designed to estimate\n    :math:`P(x_t | z_{0:t})`.  As all state transitions and observations are\n    linear with Gaussian distributed noise, these distributions can be\n    represented exactly as Gaussian distributions with mean\n    `filtered_state_means[t]` and covariances `filtered_state_covariances[t]`.\n    Similarly, the Kalman Smoother is an algorithm designed to estimate\n    :math:`P(x_t | z_{0:T-1})`.\n    The EM algorithm aims to find for\n    :math:`\\\\theta = (A, b, C, d, Q, R, \\\\mu_0, \\\\Sigma_0)`\n    .. math::\n        \\\\max_{\\\\theta} P(z_{0:T-1}; \\\\theta)\n    If we define :math:`L(x_{0:T-1},\\\\theta) = \\\\log P(z_{0:T-1}, x_{0:T-1};\n    \\\\theta)`, then the EM algorithm works by iteratively finding,\n    .. math::\n        P(x_{0:T-1} | z_{0:T-1}, \\\\theta_i)\n    then by maximizing,\n    .. math::\n        \\\\theta_{i+1} = \\\\arg\\\\max_{\\\\theta}\n            \\\\mathbb{E}_{x_{0:T-1}} [\n                L(x_{0:T-1}, \\\\theta)| z_{0:T-1}, \\\\theta_i\n            ]\n    Parameters\n    ----------\n    transition_matrices : [n_timesteps-1, n_dim_state, n_dim_state] or \\\n    [n_dim_state,n_dim_state] array-like\n        Also known as :math:`A`.  state transition matrix between times t and\n        t+1 for t in [0...n_timesteps-2]\n    observation_matrices : [n_timesteps, n_dim_obs, n_dim_state] or [n_dim_obs, \\\n    n_dim_state] array-like\n        Also known as :math:`C`.  observation matrix for times\n        [0...n_timesteps-1]\n    transition_covariance : [n_dim_state, n_dim_state] array-like\n        Also known as :math:`Q`.  state transition covariance matrix for times\n        [0...n_timesteps-2]\n    observation_covariance : [n_dim_obs, n_dim_obs] array-like\n        Also known as :math:`R`.  observation covariance matrix for times\n        [0...n_timesteps-1]\n    transition_offsets : [n_timesteps-1, n_dim_state] or [n_dim_state] \\\n    array-like\n        Also known as :math:`b`.  state offsets for times [0...n_timesteps-2]\n    observation_offsets : [n_timesteps, n_dim_obs] or [n_dim_obs] array-like\n        Also known as :math:`d`.  observation offset for times\n        [0...n_timesteps-1]\n    initial_state_mean : [n_dim_state] array-like\n        Also known as :math:`\\\\mu_0`. mean of initial state distribution\n    initial_state_covariance : [n_dim_state, n_dim_state] array-like\n        Also known as :math:`\\\\Sigma_0`.  covariance of initial state\n        distribution\n    random_state : optional, numpy random state\n        random number generator used in sampling\n    em_vars : optional, subset of ['transition_matrices', \\\n    'observation_matrices', 'transition_offsets', 'observation_offsets', \\\n    'transition_covariance', 'observation_covariance', 'initial_state_mean', \\\n    'initial_state_covariance'] or 'all'\n        if `em_vars` is an iterable of strings only variables in `em_vars`\n        will be estimated using EM.  if `em_vars` == 'all', then all\n        variables will be estimated.\n    n_dim_state: optional, integer\n        the dimensionality of the state space. Only meaningful when you do not\n        specify initial values for `transition_matrices`, `transition_offsets`,\n        `transition_covariance`, `initial_state_mean`, or\n        `initial_state_covariance`.\n    n_dim_obs: optional, integer\n        the dimensionality of the observation space. Only meaningful when you\n        do not specify initial values for `observation_matrices`,\n        `observation_offsets`, or `observation_covariance`.\n    \"\"\"\n    def __init__(self, transition_matrices=None, observation_matrices=None,\n            transition_covariance=None, observation_covariance=None,\n            transition_offsets=None, observation_offsets=None,\n            initial_state_mean=None, initial_state_covariance=None,\n            random_state=None,\n            em_vars=['transition_covariance', 'observation_covariance',\n                     'initial_state_mean', 'initial_state_covariance'],\n            n_dim_state=None, n_dim_obs=None):\n        \"\"\"Initialize Kalman Filter\"\"\"\n\n        # determine size of state space\n        n_dim_state = _determine_dimensionality(\n            [(transition_matrices, array2d, -2),\n             (transition_offsets, array1d, -1),\n             (transition_covariance, array2d, -2),\n             (initial_state_mean, array1d, -1),\n             (initial_state_covariance, array2d, -2),\n             (observation_matrices, array2d, -1)],\n            n_dim_state\n        )\n        n_dim_obs = _determine_dimensionality(\n            [(observation_matrices, array2d, -2),\n             (observation_offsets, array1d, -1),\n             (observation_covariance, array2d, -2)],\n            n_dim_obs\n        )\n\n        self.transition_matrices = transition_matrices\n        self.observation_matrices = observation_matrices\n        self.transition_covariance = transition_covariance\n        self.observation_covariance = observation_covariance\n        self.transition_offsets = transition_offsets\n        self.observation_offsets = observation_offsets\n        self.initial_state_mean = initial_state_mean\n        self.initial_state_covariance = initial_state_covariance\n        self.random_state = random_state\n        self.em_vars = em_vars\n        self.n_dim_state = n_dim_state\n        self.n_dim_obs = n_dim_obs\n\n    def sample(self, n_timesteps, initial_state=None, random_state=None):\n        \"\"\"Sample a state sequence :math:`n_{\\\\text{timesteps}}` timesteps in\n        length.\n        Parameters\n        ----------\n        n_timesteps : int\n            number of timesteps\n        Returns\n        -------\n        states : [n_timesteps, n_dim_state] array\n            hidden states corresponding to times [0...n_timesteps-1]\n        observations : [n_timesteps, n_dim_obs] array\n            observations corresponding to times [0...n_timesteps-1]\n        \"\"\"\n        (transition_matrices, transition_offsets, transition_covariance,\n         observation_matrices, observation_offsets, observation_covariance,\n         initial_state_mean, initial_state_covariance) = (\n            self._initialize_parameters()\n        )\n\n        n_dim_state = transition_matrices.shape[-2]\n        n_dim_obs = observation_matrices.shape[-2]\n        states = np.zeros((n_timesteps, n_dim_state))\n        observations = np.zeros((n_timesteps, n_dim_obs))\n\n        # logic for instantiating rng\n        if random_state is None:\n            rng = check_random_state(self.random_state)\n        else:\n            rng = check_random_state(random_state)\n\n        # logic for selecting initial state\n        if initial_state is None:\n            initial_state = rng.multivariate_normal(\n                initial_state_mean,\n                initial_state_covariance\n            )\n\n        # logic for generating samples\n        for t in range(n_timesteps):\n            if t == 0:\n                states[t] = initial_state\n            else:\n                transition_matrix = _last_dims(\n                    transition_matrices, t - 1\n                )\n                transition_offset = _last_dims(\n                    transition_offsets, t - 1, ndims=1\n                )\n                transition_covariance = _last_dims(\n                    transition_covariance, t - 1\n                )\n                states[t] = (\n                    np.dot(transition_matrix, states[t - 1])\n                    + transition_offset\n                    + rng.multivariate_normal(\n                        np.zeros(n_dim_state),\n                        transition_covariance.newbyteorder('=')\n                    )\n                )\n\n            observation_matrix = _last_dims(\n                observation_matrices, t\n            )\n            observation_offset = _last_dims(\n                observation_offsets, t, ndims=1\n            )\n            observation_covariance = _last_dims(\n                observation_covariance, t\n            )\n            observations[t] = (\n                np.dot(observation_matrix, states[t])\n                + observation_offset\n                + rng.multivariate_normal(\n                    np.zeros(n_dim_obs),\n                    observation_covariance.newbyteorder('=')\n                )\n            )\n\n        return (states, np.ma.array(observations))\n\n    def filter(self, X):\n        \"\"\"Apply the Kalman Filter\n        Apply the Kalman Filter to estimate the hidden state at time :math:`t`\n        for :math:`t = [0...n_{\\\\text{timesteps}}-1]` given observations up to\n        and including time `t`.  Observations are assumed to correspond to\n        times :math:`[0...n_{\\\\text{timesteps}}-1]`.  The output of this method\n        corresponding to time :math:`n_{\\\\text{timesteps}}-1` can be used in\n        :func:`KalmanFilter.filter_update` for online updating.\n        Parameters\n        ----------\n        X : [n_timesteps, n_dim_obs] array-like\n            observations corresponding to times [0...n_timesteps-1].  If `X` is\n            a masked array and any of `X[t]` is masked, then `X[t]` will be\n            treated as a missing observation.\n        Returns\n        -------\n        filtered_state_means : [n_timesteps, n_dim_state]\n            mean of hidden state distributions for times [0...n_timesteps-1]\n            given observations up to and including the current time step\n        filtered_state_covariances : [n_timesteps, n_dim_state, n_dim_state] \\\n        array\n            covariance matrix of hidden state distributions for times\n            [0...n_timesteps-1] given observations up to and including the\n            current time step\n        \"\"\"\n        Z = self._parse_observations(X)\n\n        (transition_matrices, transition_offsets, transition_covariance,\n         observation_matrices, observation_offsets, observation_covariance,\n         initial_state_mean, initial_state_covariance) = (\n            self._initialize_parameters()\n        )\n\n        (_, _, _, filtered_state_means,\n         filtered_state_covariances) = (\n            _filter(\n                transition_matrices, observation_matrices,\n                transition_covariance, observation_covariance,\n                transition_offsets, observation_offsets,\n                initial_state_mean, initial_state_covariance,\n                Z\n            )\n        )\n        return (filtered_state_means, filtered_state_covariances)\n\n    def filter_update(self, filtered_state_mean, filtered_state_covariance,\n                      observation=None, transition_matrix=None,\n                      transition_offset=None, transition_covariance=None,\n                      observation_matrix=None, observation_offset=None,\n                      observation_covariance=None):\n        r\"\"\"Update a Kalman Filter state estimate\n        Perform a one-step update to estimate the state at time :math:`t+1`\n        give an observation at time :math:`t+1` and the previous estimate for\n        time :math:`t` given observations from times :math:`[0...t]`.  This\n        method is useful if one wants to track an object with streaming\n        observations.\n        Parameters\n        ----------\n        filtered_state_mean : [n_dim_state] array\n            mean estimate for state at time t given observations from times\n            [1...t]\n        filtered_state_covariance : [n_dim_state, n_dim_state] array\n            covariance of estimate for state at time t given observations from\n            times [1...t]\n        observation : [n_dim_obs] array or None\n            observation from time t+1.  If `observation` is a masked array and\n            any of `observation`'s components are masked or if `observation` is\n            None, then `observation` will be treated as a missing observation.\n        transition_matrix : optional, [n_dim_state, n_dim_state] array\n            state transition matrix from time t to t+1.  If unspecified,\n            `self.transition_matrices` will be used.\n        transition_offset : optional, [n_dim_state] array\n            state offset for transition from time t to t+1.  If unspecified,\n            `self.transition_offset` will be used.\n        transition_covariance : optional, [n_dim_state, n_dim_state] array\n            state transition covariance from time t to t+1.  If unspecified,\n            `self.transition_covariance` will be used.\n        observation_matrix : optional, [n_dim_obs, n_dim_state] array\n            observation matrix at time t+1.  If unspecified,\n            `self.observation_matrices` will be used.\n        observation_offset : optional, [n_dim_obs] array\n            observation offset at time t+1.  If unspecified,\n            `self.observation_offset` will be used.\n        observation_covariance : optional, [n_dim_obs, n_dim_obs] array\n            observation covariance at time t+1.  If unspecified,\n            `self.observation_covariance` will be used.\n        Returns\n        -------\n        next_filtered_state_mean : [n_dim_state] array\n            mean estimate for state at time t+1 given observations from times\n            [1...t+1]\n        next_filtered_state_covariance : [n_dim_state, n_dim_state] array\n            covariance of estimate for state at time t+1 given observations\n            from times [1...t+1]\n        \"\"\"\n        # initialize matrices\n        (transition_matrices, transition_offsets, transition_cov,\n         observation_matrices, observation_offsets, observation_cov,\n         initial_state_mean, initial_state_covariance) = (\n            self._initialize_parameters()\n        )\n        transition_offset = _arg_or_default(\n            transition_offset, transition_offsets,\n            1, \"transition_offset\"\n        )\n        observation_offset = _arg_or_default(\n            observation_offset, observation_offsets,\n            1, \"observation_offset\"\n        )\n        transition_matrix = _arg_or_default(\n            transition_matrix, transition_matrices,\n            2, \"transition_matrix\"\n        )\n        observation_matrix = _arg_or_default(\n            observation_matrix, observation_matrices,\n            2, \"observation_matrix\"\n        )\n        transition_covariance = _arg_or_default(\n            transition_covariance, transition_cov,\n            2, \"transition_covariance\"\n        )\n        observation_covariance = _arg_or_default(\n            observation_covariance, observation_cov,\n            2, \"observation_covariance\"\n        )\n\n        # Make a masked observation if necessary\n        if observation is None:\n            n_dim_obs = observation_covariance.shape[0]\n            observation = np.ma.array(np.zeros(n_dim_obs))\n            observation.mask = True\n        else:\n            observation = np.ma.asarray(observation)\n\n        predicted_state_mean, predicted_state_covariance = (\n            _filter_predict(\n                transition_matrix, transition_covariance,\n                transition_offset, filtered_state_mean,\n                filtered_state_covariance\n            )\n        )\n        (_, next_filtered_state_mean,\n         next_filtered_state_covariance) = (\n            _filter_correct(\n                observation_matrix, observation_covariance,\n                observation_offset, predicted_state_mean,\n                predicted_state_covariance, observation\n            )\n        )\n\n        return (next_filtered_state_mean, next_filtered_state_covariance)\n\n    def smooth(self, X):\n        \"\"\"Apply the Kalman Smoother\n        Apply the Kalman Smoother to estimate the hidden state at time\n        :math:`t` for :math:`t = [0...n_{\\\\text{timesteps}}-1]` given all\n        observations.  See :func:`_smooth` for more complex output\n        Parameters\n        ----------\n        X : [n_timesteps, n_dim_obs] array-like\n            observations corresponding to times [0...n_timesteps-1].  If `X` is\n            a masked array and any of `X[t]` is masked, then `X[t]` will be\n            treated as a missing observation.\n        Returns\n        -------\n        smoothed_state_means : [n_timesteps, n_dim_state]\n            mean of hidden state distributions for times [0...n_timesteps-1]\n            given all observations\n        smoothed_state_covariances : [n_timesteps, n_dim_state]\n            covariances of hidden state distributions for times\n            [0...n_timesteps-1] given all observations\n        \"\"\"\n        Z = self._parse_observations(X)\n\n        (transition_matrices, transition_offsets, transition_covariance,\n         observation_matrices, observation_offsets, observation_covariance,\n         initial_state_mean, initial_state_covariance) = (\n            self._initialize_parameters()\n        )\n\n        (predicted_state_means, predicted_state_covariances,\n         _, filtered_state_means, filtered_state_covariances) = (\n            _filter(\n                transition_matrices, observation_matrices,\n                transition_covariance, observation_covariance,\n                transition_offsets, observation_offsets,\n                initial_state_mean, initial_state_covariance, Z\n            )\n        )\n        (smoothed_state_means, smoothed_state_covariances) = (\n            _smooth(\n                transition_matrices, filtered_state_means,\n                filtered_state_covariances, predicted_state_means,\n                predicted_state_covariances\n            )[:2]\n        )\n        return (smoothed_state_means, smoothed_state_covariances)\n\n    def em(self, X, y=None, n_iter=10, em_vars=None):\n        \"\"\"Apply the EM algorithm\n        Apply the EM algorithm to estimate all parameters specified by\n        `em_vars`.  Note that all variables estimated are assumed to be\n        constant for all time.  See :func:`_em` for details.\n        Parameters\n        ----------\n        X : [n_timesteps, n_dim_obs] array-like\n            observations corresponding to times [0...n_timesteps-1].  If `X` is\n            a masked array and any of `X[t]`'s components is masked, then\n            `X[t]` will be treated as a missing observation.\n        n_iter : int, optional\n            number of EM iterations to perform\n        em_vars : iterable of strings or 'all'\n            variables to perform EM over.  Any variable not appearing here is\n            left untouched.\n        \"\"\"\n        Z = self._parse_observations(X)\n\n        # initialize parameters\n        (self.transition_matrices, self.transition_offsets,\n         self.transition_covariance, self.observation_matrices,\n         self.observation_offsets, self.observation_covariance,\n         self.initial_state_mean, self.initial_state_covariance) = (\n            self._initialize_parameters()\n        )\n\n        # Create dictionary of variables not to perform EM on\n        if em_vars is None:\n            em_vars = self.em_vars\n\n        if em_vars == 'all':\n            given = {}\n        else:\n            given = {\n                'transition_matrices': self.transition_matrices,\n                'observation_matrices': self.observation_matrices,\n                'transition_offsets': self.transition_offsets,\n                'observation_offsets': self.observation_offsets,\n                'transition_covariance': self.transition_covariance,\n                'observation_covariance': self.observation_covariance,\n                'initial_state_mean': self.initial_state_mean,\n                'initial_state_covariance': self.initial_state_covariance\n            }\n            em_vars = set(em_vars)\n            for k in list(given.keys()):\n                if k in em_vars:\n                    given.pop(k)\n\n        # If a parameter is time varying, print a warning\n        for (k, v) in get_params(self).items():\n            if k in DIM and (not k in given) and len(v.shape) != DIM[k]:\n                warn_str = (\n                    '{0} has {1} dimensions now; after fitting, '\n                    + 'it will have dimension {2}'\n                ).format(k, len(v.shape), DIM[k])\n                warnings.warn(warn_str)\n\n        # Actual EM iterations\n        for i in range(n_iter):\n            (predicted_state_means, predicted_state_covariances,\n             kalman_gains, filtered_state_means,\n             filtered_state_covariances) = (\n                _filter(\n                    self.transition_matrices, self.observation_matrices,\n                    self.transition_covariance, self.observation_covariance,\n                    self.transition_offsets, self.observation_offsets,\n                    self.initial_state_mean, self.initial_state_covariance,\n                    Z\n                )\n            )\n            (smoothed_state_means, smoothed_state_covariances,\n             kalman_smoothing_gains) = (\n                _smooth(\n                    self.transition_matrices, filtered_state_means,\n                    filtered_state_covariances, predicted_state_means,\n                    predicted_state_covariances\n                )\n            )\n            sigma_pair_smooth = _smooth_pair(\n                smoothed_state_covariances,\n                kalman_smoothing_gains\n            )\n            (self.transition_matrices,  self.observation_matrices,\n             self.transition_offsets, self.observation_offsets,\n             self.transition_covariance, self.observation_covariance,\n             self.initial_state_mean, self.initial_state_covariance) = (\n                _em(Z, self.transition_offsets, self.observation_offsets,\n                    smoothed_state_means, smoothed_state_covariances,\n                    sigma_pair_smooth, given=given\n                )\n            )\n        return self\n\n    def loglikelihood(self, X):\n        \"\"\"Calculate the log likelihood of all observations\n        Parameters\n        ----------\n        X : [n_timesteps, n_dim_obs] array\n            observations for time steps [0...n_timesteps-1]\n        Returns\n        -------\n        likelihood : float\n            likelihood of all observations\n        \"\"\"\n        Z = self._parse_observations(X)\n\n        # initialize parameters\n        (transition_matrices, transition_offsets,\n         transition_covariance, observation_matrices,\n         observation_offsets, observation_covariance,\n         initial_state_mean, initial_state_covariance) = (\n            self._initialize_parameters()\n        )\n\n        # apply the Kalman Filter\n        (predicted_state_means, predicted_state_covariances,\n         kalman_gains, filtered_state_means,\n         filtered_state_covariances) = (\n            _filter(\n                transition_matrices, observation_matrices,\n                transition_covariance, observation_covariance,\n                transition_offsets, observation_offsets,\n                initial_state_mean, initial_state_covariance,\n                Z\n            )\n        )\n\n        # get likelihoods for each time step\n        loglikelihoods = _loglikelihoods(\n          observation_matrices, observation_offsets, observation_covariance,\n          predicted_state_means, predicted_state_covariances, Z\n        )\n\n        return np.sum(loglikelihoods)\n\n    def _initialize_parameters(self):\n        \"\"\"Retrieve parameters if they exist, else replace with defaults\"\"\"\n        n_dim_state, n_dim_obs = self.n_dim_state, self.n_dim_obs\n\n        arguments = get_params(self)\n        defaults = {\n            'transition_matrices': np.eye(n_dim_state),\n            'transition_offsets': np.zeros(n_dim_state),\n            'transition_covariance': np.eye(n_dim_state),\n            'observation_matrices': np.eye(n_dim_obs, n_dim_state),\n            'observation_offsets': np.zeros(n_dim_obs),\n            'observation_covariance': np.eye(n_dim_obs),\n            'initial_state_mean': np.zeros(n_dim_state),\n            'initial_state_covariance': np.eye(n_dim_state),\n            'random_state': 0,\n            'em_vars': [\n                'transition_covariance',\n                'observation_covariance',\n                'initial_state_mean',\n                'initial_state_covariance'\n            ],\n        }\n        converters = {\n            'transition_matrices': array2d,\n            'transition_offsets': array1d,\n            'transition_covariance': array2d,\n            'observation_matrices': array2d,\n            'observation_offsets': array1d,\n            'observation_covariance': array2d,\n            'initial_state_mean': array1d,\n            'initial_state_covariance': array2d,\n            'random_state': check_random_state,\n            'n_dim_state': int,\n            'n_dim_obs': int,\n            'em_vars': lambda x: x,\n        }\n\n        parameters = preprocess_arguments([arguments, defaults], converters)\n\n        return (\n            parameters['transition_matrices'],\n            parameters['transition_offsets'],\n            parameters['transition_covariance'],\n            parameters['observation_matrices'],\n            parameters['observation_offsets'],\n            parameters['observation_covariance'],\n            parameters['initial_state_mean'],\n            parameters['initial_state_covariance']\n        )\n\n    def _parse_observations(self, obs):\n        \"\"\"Safely convert observations to their expected format\"\"\"\n        obs = np.ma.atleast_2d(obs)\n        if obs.shape[0] == 1 and obs.shape[1] > 1:\n            obs = obs.T\n        return obs\n```\n\n## 相关滤波器 \n\n> csdn-blog (https://blog.csdn.net/sgfmby1994/article/details/68490903)\n\n1. 对于输入的第一帧，将给定的要追踪的区域提取特征，然后进行训练，得到相关滤波器\n2. 对于之后的每一帧，先裁剪下之前预测的区域，然后进行特征提取。\n3. 这些特征经过cos窗函数之后，进行fft变换(简化计算量),然后与相关滤波器相乘。\n4. 将步骤3的结果作ifft,最大响应点所在的区域就是要追踪的新位置。\n5. 重复1-4步骤。","tags":[],"folderPathname":"/图像处理","data":{},"createdAt":"2020-12-07T07:44:35.431Z","updatedAt":"2020-12-07T10:02:09.135Z","trashed":false,"_rev":"zWZnJJaCU"}